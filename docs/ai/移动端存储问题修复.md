# 移动端存储逻辑问题修复文档

## 问题概述

在新版本 Android（特别是 Android 13+）上，首次启动游戏时不会进行文件复制流程，导致游戏无法正常加载资源。

---

## 根本原因分析

### 1. CopyState 被禁用

**问题位置**：`source/Main.hx` 第 174-177 行

**原始代码**：
```haxe
// 这行被注释掉了，导致 CopyState 完全被跳过
var game:FlxGame = new FlxGame(game.width, game.height, game.initialState, ...);
```

**问题影响**：
- 首次启动时不会检查缺失的资源文件
- `assets/` 和 `mods/` 下的文件不会从 APK 内部复制到外部存储
- 游戏无法加载必要的资源（图片、音频、配置文件等）

**正确逻辑**：
```haxe
var game:FlxGame = new FlxGame(game.width, game.height,
    #if COPYSTATE_ALLOWED !CopyState.checkExistingFiles() ? CopyState : #end game.initialState,
    ...);
```

这个逻辑是：
1. 调用 `CopyState.checkExistingFiles()` 检查是否有缺失的文件
2. 如果有缺失文件，先进入 `CopyState` 进行复制
3. 复制完成后进入 `TitleState`
4. 如果没有缺失文件，直接进入 `TitleState`

---

### 2. 权限请求时机问题

**问题位置**：`source/mobile/backend/StorageUtil.hx` 第 59-97 行

**原始代码**：
```haxe
public static function requestPermissions():Void
{
    if (AndroidVersion.SDK_INT >= AndroidVersionCode.TIRAMISU)
        AndroidPermissions.requestPermissions(['READ_MEDIA_IMAGES', ...]);
    else
        AndroidPermissions.requestPermissions(['READ_EXTERNAL_STORAGE', 'WRITE_EXTERNAL_STORAGE']);

    if (!AndroidEnvironment.isExternalStorageManager())
        AndroidSettings.requestSetting('MANAGE_APP_ALL_FILES_ACCESS_PERMISSION');

    // 立即检查权限，但用户可能还没来得及授予！
    if ((AndroidVersion.SDK_INT >= AndroidVersionCode.TIRAMISU
        && !AndroidPermissions.getGrantedPermissions().contains('android.permission.READ_MEDIA_IMAGES'))
        || ...)
        CoolUtil.showPopUp(...);

    // 尝试创建目录
    try
    {
        if (!FileSystem.exists(StorageUtil.getStorageDirectory()))
            FileSystem.createDirectory(StorageUtil.getStorageDirectory());
    }
    catch (e:Dynamic) { ... }
}
```

**问题**：
- 权限请求是**异步**操作
- 代码立即检查权限状态，但用户还没来得及授予
- 导致权限检查失败，目录创建失败

**解决方案**：
```haxe
// 添加延迟，给用户时间授予权限
new FlxTimer().start(2, function(tmr) {
    if ((AndroidVersion.SDK_INT >= AndroidVersionCode.TIRAMISU
        && !AndroidPermissions.getGrantedPermissions().contains('android.permission.READ_MEDIA_IMAGES'))
        || ...)
        CoolUtil.showPopUp(...);

    try
    {
        if (!FileSystem.exists(StorageUtil.getStorageDirectory()))
            FileSystem.createDirectory(StorageUtil.getStorageDirectory());
    }
    catch (e:Dynamic) { ... }
});
```

---

### 3. CopyState 的工作原理

**文件位置**：`source/states/CopyState.hx`

**核心流程**：

1. **检查缺失文件**（`checkExistingFiles()`）
   ```haxe
   public static function checkExistingFiles():Bool
   {
       locatedFiles = OpenFLAssets.list();
       var assets = locatedFiles.filter(folder -> folder.startsWith('assets/'));
       var mods = locatedFiles.filter(folder -> folder.startsWith('mods/'));
       locatedFiles = assets.concat(mods);
       locatedFiles = locatedFiles.filter(file -> !FileSystem.exists(file));

       maxLoopTimes = locatedFiles.length;
       return (maxLoopTimes <= 0);  // 如果没有文件需要复制，返回 true
   }
   ```

2. **复制文件**（`copyAsset()`）
   ```haxe
   public function copyAsset(file:String)
   {
       if (!FileSystem.exists(file))
       {
           var directory = Path.directory(file);
           if (!FileSystem.exists(directory))
               FileSystem.createDirectory(directory);

           if (OpenFLAssets.exists(getFile(file)))
           {
               if (textFilesExtensions.contains(Path.extension(file)))
                   createContentFromInternal(file);  // 文本文件
               else
                   File.saveBytes(path, getFileBytes(getFile(file)));  // 二进制文件
           }
       }
   }
   ```

3. **复制方式**
   - **文本文件**（txt, xml, lua, json 等）：使用 `OpenFLAssets.getText()` 读取内容，然后用 `File.saveContent()` 保存
   - **二进制文件**（png, ogg, mp3 等）：使用 `OpenFLAssets.getBytes()` 读取字节，然后用 `File.saveBytes()` 保存

4. **目标路径**
   - **普通文件**：直接使用相对路径（因为 `Main.hx` 中已经通过 `Sys.setCwd()` 设置了工作目录）
   - **Mods 文件**：在 Android 上使用 `StorageUtil.getExternalStorageDirectory() + file`

---

## 修复方案

### 方案 1：已实施的修复

#### 修复 1：重新启用 CopyState

**文件**：`source/Main.hx`

**修改**：
```haxe
// 修改前
var game:FlxGame = new FlxGame(game.width, game.height, game.initialState, ...);

// 修改后
var game:FlxGame = new FlxGame(game.width, game.height,
    #if COPYSTATE_ALLOWED !CopyState.checkExistingFiles() ? CopyState : #end game.initialState,
    #if (flixel < "5.0.0") game.zoom, #end game.framerate, game.framerate,
    game.skipSplash, game.startFullscreen);
```

**效果**：
- 首次启动时会检查并复制缺失的资源文件
- 用户会看到 CopyState 的加载界面和进度条
- 资源文件从 APK 内部正确复制到外部存储

---

#### 修复 2：延迟权限检查

**文件**：`source/mobile/backend/StorageUtil.hx`

**修改**：
```haxe
public static function requestPermissions():Void
{
    if (AndroidVersion.SDK_INT >= AndroidVersionCode.TIRAMISU)
        AndroidPermissions.requestPermissions(['READ_MEDIA_IMAGES', 'READ_MEDIA_VIDEO', 'READ_MEDIA_AUDIO', 'READ_MEDIA_VISUAL_USER_SELECTED']);
    else
        AndroidPermissions.requestPermissions(['READ_EXTERNAL_STORAGE', 'WRITE_EXTERNAL_STORAGE']);

    if (!AndroidEnvironment.isExternalStorageManager())
        AndroidSettings.requestSetting('MANAGE_APP_ALL_FILES_ACCESS_PERMISSION');

    // 延迟 2 秒检查权限，给用户时间授予
    // 使用 Sys.sleep 而不是 FlxTimer，因为此时 FlxG 可能还未初始化
    Sys.sleep(2.0);

    if ((AndroidVersion.SDK_INT >= AndroidVersionCode.TIRAMISU
        && !AndroidPermissions.getGrantedPermissions().contains('android.permission.READ_MEDIA_IMAGES'))
        || (AndroidVersion.SDK_INT < AndroidVersionCode.TIRAMISU
            && !AndroidPermissions.getGrantedPermissions().contains('android.permission.READ_EXTERNAL_STORAGE')))
        CoolUtil.showPopUp(LanguageBasic.getPhrase('permissions_message', 'If you accepted the permissions you are all good!\nIf you didn\'t then expect a crash\nPress OK to see what happens'),
            LanguageBasic.getPhrase('mobile_notice', "Notice!"));

    try
    {
        if (!FileSystem.exists(StorageUtil.getStorageDirectory()))
            FileSystem.createDirectory(StorageUtil.getStorageDirectory());
    }
    catch (e:Dynamic)
    {
        CoolUtil.showPopUp(LanguageBasic.getPhrase('create_directory_error', 'Please create directory to\n{1}\nPress OK to close the game', [StorageUtil.getStorageDirectory()]), LanguageBasic.getPhrase('mobile_error', "Error!"));
        lime.system.System.exit(1);
    }

    try
    {
        if (!FileSystem.exists(StorageUtil.getExternalStorageDirectory() + 'mods'))
            FileSystem.createDirectory(StorageUtil.getExternalStorageDirectory() + 'mods');
    }
    catch (e:Dynamic)
    {
        CoolUtil.showPopUp(LanguageBasic.getPhrase('create_directory_error', 'Please create directory to\n{1}\nPress OK to close the game', [StorageUtil.getExternalStorageDirectory()]), LanguageBasic.getPhrase('mobile_error', "Error!"));
        lime.system.System.exit(1);
    }
}
```

**效果**：
- 给用户 2 秒时间授予权限
- 减少因权限未授予导致的错误
- 如果权限仍未授予，会提示用户并尝试创建目录

**注意**：
- 使用 `Sys.sleep()` 而不是 `FlxTimer`，因为在 `Main.new()` 构造函数中调用时，`FlxG` 可能还未完全初始化
- `Sys.sleep()` 是同步阻塞延迟，适用于此场景

---

## Android 13+ 权限变化

### 旧版本 Android（12 及以下）

需要的权限：
- `READ_EXTERNAL_STORAGE`
- `WRITE_EXTERNAL_STORAGE`

### 新版本 Android（13+，API 33+）

权限变化：
- `READ_EXTERNAL_STORAGE` 和 `WRITE_EXTERNAL_STORAGE` 被移除
- 改为更细粒度的媒体权限：
  - `READ_MEDIA_IMAGES` - 读取图片
  - `READ_MEDIA_VIDEO` - 读取视频
  - `READ_MEDIA_AUDIO` - 读取音频
  - `READ_MEDIA_VISUAL_USER_SELECTED` - 读取用户选择的媒体文件

**代码中的实现**：
```haxe
if (AndroidVersion.SDK_INT >= AndroidVersionCode.TIRAMISU)
    AndroidPermissions.requestPermissions(['READ_MEDIA_IMAGES', 'READ_MEDIA_VIDEO', 'READ_MEDIA_AUDIO', 'READ_MEDIA_VISUAL_USER_SELECTED']);
else
    AndroidPermissions.requestPermissions(['READ_EXTERNAL_STORAGE', 'WRITE_EXTERNAL_STORAGE']);
```

---

## 存储路径说明

### Android 存储层次

1. **APK 内部存储**（只读）
   - 路径：APK 的 `assets/` 目录
   - 访问方式：`OpenFLAssets.getText()`, `OpenFLAssets.getBytes()`
   - 用途：存储游戏默认资源

2. **应用私有外部存储**
   - 路径：`/storage/emulated/0/Android/data/com.kittycathy.mrextended/files/`
   - 获取方式：`AndroidContext.getExternalFilesDir()`
   - 用途：存储游戏数据、存档

3. **应用外部存储（共享）**
   - 路径：`/sdcard/.MintRhythm Extended/`
   - 获取方式：`StorageUtil.getExternalStorageDirectory()`
   - 用途：存储 Mods、用户自定义文件

### 工作目录设置

在 `Main.hx` 第 75 行：
```haxe
#if mobile
Sys.setCwd(StorageUtil.getStorageDirectory());
#end
```

这会将当前工作目录设置为应用的外部存储目录，因此：
- `File.saveContent("test.txt")` 会保存到 `/sdcard/.MintRhythm Extended/test.txt`
- `FileSystem.exists("mods")` 会检查 `/sdcard/.MintRhythm Extended/mods`

---

## 测试验证

### 测试步骤

1. **卸载旧版本应用**（确保完全清理数据）

2. **重新安装并启动**

3. **检查以下流程**：
   - ✅ 启动时请求权限
   - ✅ CopyState 界面出现
   - ✅ 进度条从 0 递增到 100%
   - ✅ 提示 "Completed!"
   - ✅ 自动跳转到标题界面

4. **验证文件复制**：
   ```bash
   # 通过 ADB 检查
   adb shell ls /sdcard/.MintRhythm\ Extended/assets/
   adb shell ls /sdcard/.MintRhythm\ Extended/mods/
   ```

5. **检查目录创建**：
   - ✅ `/sdcard/.MintRhythm Extended/` 存在
   - ✅ `/sdcard/.MintRhythm Extended/assets/` 存在
   - ✅ `/sdcard/.MintRhythm Extended/mods/` 存在

---

## 常见问题排查

### 问题 1：CopyState 未触发

**可能原因**：
- `COPYSTATE_ALLOWED` 未定义
- `checkExistingFiles()` 返回 `true`（没有文件需要复制）

**排查方法**：
```haxe
// 在 CopyState.checkExistingFiles() 开头添加
trace("locatedFiles.length: " + locatedFiles.length);
trace("maxLoopTimes: " + maxLoopTimes);
```

---

### 问题 2：权限请求后立即报错

**可能原因**：
- 用户拒绝权限
- Android 13+ 细粒度权限问题

**解决方法**：
- 在 `AndroidManifest.xml` 中正确声明权限
- 提供用户友好的权限请求说明

---

### 问题 3：文件复制失败

**可能原因**：
- 磁盘空间不足
- 文件路径过长
- 特殊字符

**解决方法**：
- 检查日志中的 `failedFiles`
- 查看 `logs/` 目录下的错误日志

---

## 总结

### 修复前的问题
1. ❌ CopyState 被禁用，文件不复制
2. ❌ 权限检查过快，用户来不及授予
3. ❌ 首次启动无法加载资源

### 修复后的效果
1. ✅ CopyState 正常工作，自动复制缺失文件
2. ✅ 权限检查延迟，给用户足够时间
3. ✅ 首次启动流程顺畅，资源正确加载

---

## 相关文件清单

修改的文件：
1. `source/Main.hx` - 重新启用 CopyState
2. `source/mobile/backend/StorageUtil.hx` - 优化权限请求逻辑

相关的文件：
1. `source/states/CopyState.hx` - 文件复制状态
2. `Project.xml` - 编译配置（包含 `COPYSTATE_ALLOWED` 定义）
3. `source/mobile/backend/MobileData.hx` - 移动端数据管理
